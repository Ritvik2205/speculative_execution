#!/usr/bin/env python3
"""
Comprehensive Test Suite for Vulnerability Detection System
Tests the robust detection system against known vulnerable assembly code
"""

import os
import json
import re
from pathlib import Path
from typing import List, Dict, Any

from robust_vulnerability_detector import RobustVulnerabilityDetector
from semantic_vulnerability_analyzer import SemanticVulnerabilityAnalyzer
from ensemble_vulnerability_detector import EnsembleVulnerabilityDetector

class VulnerabilityTestSuite:
    """Test suite for vulnerability detection systems"""
    
    def __init__(self):
        self.test_results = []
        self.vuln_asm_dir = "../c_vulns/asm_code"
        
    def load_test_cases(self) -> List[Dict[str, Any]]:
        """Load test cases from vulnerable assembly files"""
        test_cases = []
        
        if not os.path.exists(self.vuln_asm_dir):
            print(f"❌ Vulnerable assembly directory not found: {self.vuln_asm_dir}")
            return test_cases
        
        asm_files = list(Path(self.vuln_asm_dir).glob("*.s"))
        
        for asm_file in asm_files[:2]:  # Test first 2 files for quick testing
            print(f"📄 Loading test case: {asm_file.name}")
            
            # Parse vulnerability type and architecture
            vuln_type, arch = self._parse_filename(asm_file.name)
            
            # Read and parse assembly
            with open(asm_file, 'r') as f:
                asm_content = f.read()
            
            # Extract function-level test cases
            functions = self._extract_functions(asm_content)
            
            for func_name, func_content in functions.items():
                if len(func_content) > 10:  # Only test substantial functions
                    instructions = self._parse_assembly_to_instructions(func_content, arch)
                    
                    if len(instructions) >= 5:  # Need minimum instructions
                        test_case = {
                            'name': f"{asm_file.stem}_{func_name}",
                            'file': str(asm_file),
                            'function': func_name,
                            'expected_vuln_type': vuln_type,
                            'architecture': arch,
                            'instructions': instructions,
                            'raw_content': func_content
                        }
                        test_cases.append(test_case)
        
        print(f"✅ Loaded {len(test_cases)} test cases")
        return test_cases
    
    def _parse_filename(self, filename: str) -> tuple:
        """Parse vulnerability type and architecture from filename"""
        filename_lower = filename.lower()
        
        # Extract vulnerability type
        vuln_type = "UNKNOWN"
        if "spectre_1" in filename_lower or "spectre_v1" in filename_lower:
            vuln_type = "SPECTRE_V1"
        elif "spectre_2" in filename_lower:
            vuln_type = "SPECTRE_V2"
        elif "meltdown" in filename_lower:
            vuln_type = "MELTDOWN"
        elif "retbleed" in filename_lower:
            vuln_type = "RETBLEED"
        elif "bhi" in filename_lower:
            vuln_type = "BHI"
        elif "inception" in filename_lower:
            vuln_type = "INCEPTION"
        elif "l1tf" in filename_lower:
            vuln_type = "L1TF"
        elif "mds" in filename_lower:
            vuln_type = "MDS"
        
        # Extract architecture
        arch = "x86_64"  # default
        if "arm" in filename_lower or "aarch64" in filename_lower:
            arch = "arm64"
        elif "x86" in filename_lower:
            arch = "x86_64"
        
        return vuln_type, arch
    
    def _extract_functions(self, asm_content: str) -> Dict[str, str]:
        """Extract functions from assembly content"""
        functions = {}
        lines = asm_content.split('\n')
        current_function = None
        current_content = []
        
        for line in lines:
            line = line.strip()
            
            # Look for function labels
            if ':' in line and not line.startswith('.') and not line.startswith('#'):
                # Save previous function
                if current_function and current_content:
                    functions[current_function] = '\n'.join(current_content)
                
                # Start new function
                current_function = line.split(':')[0].strip()
                current_content = []
            else:
                if current_function and line and not line.startswith('.'):
                    current_content.append(line)
        
        # Save last function
        if current_function and current_content:
            functions[current_function] = '\n'.join(current_content)
        
        # If no functions found, treat entire content as main function
        if not functions:
            functions['main'] = asm_content
        
        return functions
    
    def _parse_assembly_to_instructions(self, asm_content: str, arch: str) -> List[Dict]:
        """Parse assembly content to instruction format"""
        instructions = []
        lines = asm_content.split('\n')
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line or line.startswith('.') or line.startswith('#') or ':' in line:
                continue
            
            # Basic instruction parsing
            parts = line.split()
            if not parts:
                continue
                
            opcode = parts[0].lower()
            operands = parts[1:] if len(parts) > 1 else []
            
            # Analyze instruction semantics
            semantics = self._analyze_instruction_semantics(opcode, operands, arch)
            
            instruction = {
                'line_num': i + 1,
                'raw_line': line,
                'opcode': opcode,
                'operands': operands,
                'semantics': semantics
            }
            
            instructions.append(instruction)
        
        return instructions
    
    def _analyze_instruction_semantics(self, opcode: str, operands: List[str], arch: str) -> Dict[str, bool]:
        """Analyze semantic properties of an instruction"""
        semantics = {
            'is_branch': False,
            'is_conditional': False,
            'is_indirect': False,
            'is_call': False,
            'is_return': False,
            'is_load': False,
            'is_store': False,
            'accesses_memory': False,
            'is_arithmetic': False,
            'is_comparison': False,
            'is_speculation_barrier': False,
            'is_cache_operation': False,
            'is_timing_sensitive': False,
            'is_privileged': False
        }
        
        if arch == 'x86_64':
            # x86-64 instruction semantics
            if opcode.startswith('j'):
                semantics['is_branch'] = True
                if opcode != 'jmp':
                    semantics['is_conditional'] = True
                if any('[' in op for op in operands):
                    semantics['is_indirect'] = True
            elif opcode in ['call', 'ret']:
                semantics['is_call'] = opcode == 'call'
                semantics['is_return'] = opcode == 'ret'
                if opcode == 'call' and any('[' in op or '%' in op for op in operands):
                    semantics['is_indirect'] = True
            elif opcode in ['mov', 'movzx', 'movsx', 'movzbl', 'movzwl', 'lea']:
                if any('[' in op for op in operands):
                    semantics['accesses_memory'] = True
                    semantics['is_load'] = True
            elif opcode in ['add', 'sub', 'mul', 'div', 'xor', 'and', 'or', 'shl', 'shr']:
                semantics['is_arithmetic'] = True
            elif opcode in ['cmp', 'test']:
                semantics['is_comparison'] = True
            elif opcode in ['lfence', 'mfence', 'sfence']:
                semantics['is_speculation_barrier'] = True
            elif opcode in ['clflush', 'clwb', 'clflushopt']:
                semantics['is_cache_operation'] = True
            elif opcode in ['rdtsc', 'rdtscp']:
                semantics['is_timing_sensitive'] = True
                
        elif arch == 'arm64':
            # ARM64 instruction semantics
            if opcode.startswith('b'):
                semantics['is_branch'] = True
                if '.' in opcode:  # conditional branches like b.eq
                    semantics['is_conditional'] = True
                if opcode in ['br', 'blr']:
                    semantics['is_indirect'] = True
            elif opcode in ['bl', 'blr', 'ret']:
                semantics['is_call'] = opcode in ['bl', 'blr']
                semantics['is_return'] = opcode == 'ret'
                if opcode == 'blr':
                    semantics['is_indirect'] = True
            elif opcode in ['ldr', 'ldrb', 'ldrh', 'ldp']:
                semantics['is_load'] = True
                semantics['accesses_memory'] = True
            elif opcode in ['str', 'strb', 'strh', 'stp']:
                semantics['is_store'] = True
                semantics['accesses_memory'] = True
            elif opcode in ['add', 'sub', 'mul', 'div', 'and', 'orr', 'eor', 'lsl', 'lsr']:
                semantics['is_arithmetic'] = True
            elif opcode in ['cmp', 'subs']:
                semantics['is_comparison'] = True
            elif opcode in ['dsb', 'isb', 'dmb']:
                semantics['is_speculation_barrier'] = True
            elif opcode in ['dc', 'ic']:
                semantics['is_cache_operation'] = True
            elif opcode == 'mrs':
                semantics['is_timing_sensitive'] = True
                semantics['is_privileged'] = True
        
        return semantics
    
    def test_robust_detector(self, test_cases: List[Dict]) -> List[Dict]:
        """Test the robust vulnerability detector"""
        print("\n🤖 Testing Robust Vulnerability Detector")
        
        detector = RobustVulnerabilityDetector()
        
        # Train on vulnerable code (skip loading pickled models to avoid class issues)
        signatures = detector.analyze_vulnerable_code(self.vuln_asm_dir)
        detector.vulnerability_signatures = signatures
        detector.build_ml_classifier(signatures)
        print(f"   🎓 Trained on {len(signatures)} signatures")
        
        results = []
        
        for i, test_case in enumerate(test_cases):
            print(f"   🧪 Testing {test_case['name']} ({i+1}/{len(test_cases)})")
            
            detections = detector.detect_vulnerabilities(
                test_case['instructions'], 
                test_case['architecture']
            )
            
            result = {
                'test_case': test_case['name'],
                'expected': test_case['expected_vuln_type'],
                'architecture': test_case['architecture'],
                'detections': len(detections),
                'detected_types': [],
                'max_confidence': 0.0,
                'correct_detection': False
            }
            
            if detections:
                result['detected_types'] = list(set([
                    d.get('vulnerability_types', [d.get('vuln_type', 'UNKNOWN')])[0] 
                    if isinstance(d.get('vulnerability_types', d.get('vuln_type', 'UNKNOWN')), list)
                    else d.get('vulnerability_types', d.get('vuln_type', 'UNKNOWN'))
                    for d in detections
                ]))
                result['max_confidence'] = max([
                    d.get('primary_confidence', d.get('confidence', 0.0)) 
                    for d in detections
                ])
                result['correct_detection'] = test_case['expected_vuln_type'] in result['detected_types']
            
            results.append(result)
            
            print(f"      Expected: {result['expected']}")
            print(f"      Detected: {result['detected_types']} (conf: {result['max_confidence']:.3f})")
            print(f"      Correct: {'✅' if result['correct_detection'] else '❌'}")
        
        return results
    
    def test_semantic_analyzer(self, test_cases: List[Dict]) -> List[Dict]:
        """Test the semantic vulnerability analyzer"""
        print("\n🧠 Testing Semantic Vulnerability Analyzer")
        
        analyzer = SemanticVulnerabilityAnalyzer()
        results = []
        
        for i, test_case in enumerate(test_cases):
            print(f"   🧪 Testing {test_case['name']} ({i+1}/{len(test_cases)})")
            
            context = analyzer.analyze_code_semantics(test_case['instructions'])
            detections = analyzer.detect_semantic_vulnerabilities(
                test_case['instructions'], context
            )
            
            result = {
                'test_case': test_case['name'],
                'expected': test_case['expected_vuln_type'],
                'architecture': test_case['architecture'],
                'detections': len(detections),
                'detected_types': [d['vuln_type'] for d in detections],
                'max_confidence': max([d['confidence'] for d in detections]) if detections else 0.0,
                'correct_detection': test_case['expected_vuln_type'] in [d['vuln_type'] for d in detections]
            }
            
            results.append(result)
            
            print(f"      Expected: {result['expected']}")
            print(f"      Detected: {result['detected_types']} (conf: {result['max_confidence']:.3f})")
            print(f"      Correct: {'✅' if result['correct_detection'] else '❌'}")
        
        return results
    
    def test_ensemble_detector(self, test_cases: List[Dict]) -> List[Dict]:
        """Test the ensemble vulnerability detector"""
        print("\n🎯 Testing Ensemble Vulnerability Detector")
        
        ensemble = EnsembleVulnerabilityDetector()
        
        # Train ensemble (skip loading pickled models to avoid class issues)
        ensemble.train_ensemble(self.vuln_asm_dir)
        print("   🎓 Trained ensemble detector")
        
        results = []
        
        for i, test_case in enumerate(test_cases):
            print(f"   🧪 Testing {test_case['name']} ({i+1}/{len(test_cases)})")
            
            detections = ensemble.detect_vulnerabilities(
                test_case['instructions'], 
                test_case['architecture']
            )
            
            result = {
                'test_case': test_case['name'],
                'expected': test_case['expected_vuln_type'],
                'architecture': test_case['architecture'],
                'detections': len(detections),
                'detected_types': [d.vuln_type for d in detections],
                'max_confidence': max([d.confidence for d in detections]) if detections else 0.0,
                'correct_detection': test_case['expected_vuln_type'] in [d.vuln_type for d in detections]
            }
            
            results.append(result)
            
            print(f"      Expected: {result['expected']}")
            print(f"      Detected: {result['detected_types']} (conf: {result['max_confidence']:.3f})")
            print(f"      Correct: {'✅' if result['correct_detection'] else '❌'}")
        
        return results
    
    def generate_test_report(self, robust_results: List[Dict], 
                           semantic_results: List[Dict], 
                           ensemble_results: List[Dict]):
        """Generate comprehensive test report"""
        
        report = {
            'test_summary': {
                'total_test_cases': len(robust_results),
                'robust_detector': self._calculate_metrics(robust_results),
                'semantic_analyzer': self._calculate_metrics(semantic_results),
                'ensemble_detector': self._calculate_metrics(ensemble_results)
            },
            'detailed_results': {
                'robust_detector': robust_results,
                'semantic_analyzer': semantic_results,
                'ensemble_detector': ensemble_results
            }
        }
        
        # Save report
        with open('vulnerability_detection_test_report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        # Print summary
        print("\n" + "="*80)
        print("VULNERABILITY DETECTION TEST RESULTS")
        print("="*80)
        
        print(f"\n📊 Test Summary ({report['test_summary']['total_test_cases']} test cases)")
        
        for detector_name, metrics in report['test_summary'].items():
            if detector_name != 'total_test_cases':
                print(f"\n🔍 {detector_name.replace('_', ' ').title()}:")
                print(f"   Accuracy: {metrics['accuracy']:.1%}")
                print(f"   Precision: {metrics['precision']:.1%}")
                print(f"   Recall: {metrics['recall']:.1%}")
                print(f"   F1-Score: {metrics['f1_score']:.1%}")
                print(f"   Avg Confidence: {metrics['avg_confidence']:.3f}")
        
        print(f"\n📁 Detailed report saved to: vulnerability_detection_test_report.json")
        
        return report
    
    def _calculate_metrics(self, results: List[Dict]) -> Dict[str, float]:
        """Calculate performance metrics"""
        if not results:
            return {'accuracy': 0.0, 'precision': 0.0, 'recall': 0.0, 'f1_score': 0.0, 'avg_confidence': 0.0}
        
        correct_detections = sum(1 for r in results if r['correct_detection'])
        total_detections = sum(1 for r in results if r['detections'] > 0)
        total_cases = len(results)
        
        accuracy = correct_detections / total_cases if total_cases > 0 else 0.0
        precision = correct_detections / total_detections if total_detections > 0 else 0.0
        recall = correct_detections / total_cases if total_cases > 0 else 0.0
        f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0.0
        avg_confidence = sum(r['max_confidence'] for r in results) / total_cases if total_cases > 0 else 0.0
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1_score,
            'avg_confidence': avg_confidence
        }

def main():
    """Run comprehensive vulnerability detection tests"""
    print("🧪 Starting Comprehensive Vulnerability Detection Test Suite")
    
    test_suite = VulnerabilityTestSuite()
    
    # Load test cases
    test_cases = test_suite.load_test_cases()
    
    if not test_cases:
        print("❌ No test cases loaded. Exiting.")
        return
    
    # Test all detectors
    robust_results = test_suite.test_robust_detector(test_cases)
    semantic_results = test_suite.test_semantic_analyzer(test_cases)
    ensemble_results = test_suite.test_ensemble_detector(test_cases)
    
    # Generate comprehensive report
    test_suite.generate_test_report(robust_results, semantic_results, ensemble_results)

if __name__ == "__main__":
    main()