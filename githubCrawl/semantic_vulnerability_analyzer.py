#!/usr/bin/env python3
"""
Semantic Vulnerability Analyzer
Focuses on understanding the context and meaning of vulnerable patterns
"""

import os
import re
import json
import numpy as np
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import List, Dict, Set, Tuple, Optional, Any
from pathlib import Path
import networkx as nx
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

@dataclass
class SemanticContext:
    """Represents semantic context of a code region"""
    function_name: str
    variable_dependencies: Dict[str, List[str]]
    control_flow_context: List[str]
    data_flow_context: List[str]
    speculation_context: Dict[str, Any]
    vulnerability_indicators: List[str]
    confidence_factors: Dict[str, float]

@dataclass
class VulnerabilityPattern:
    """High-level vulnerability pattern with semantic understanding"""
    pattern_id: str
    vuln_type: str
    description: str
    semantic_requirements: List[str]
    code_patterns: List[str]
    context_requirements: Dict[str, Any]
    detection_heuristics: List[str]
    false_positive_filters: List[str]

class SemanticVulnerabilityAnalyzer:
    """Advanced semantic analysis for vulnerability detection"""
    
    def __init__(self):
        self.vulnerability_patterns = self._load_semantic_patterns()
        self.context_analyzer = ContextAnalyzer()
        self.speculation_analyzer = SpeculationAnalyzer()
        self.data_flow_analyzer = DataFlowAnalyzer()
        
    def _load_semantic_patterns(self) -> List[VulnerabilityPattern]:
        """Load high-level semantic vulnerability patterns"""
        patterns = []
        
        # Spectre V1 patterns
        patterns.append(VulnerabilityPattern(
            pattern_id="SPECTRE_V1_BOUNDS_BYPASS",
            vuln_type="SPECTRE_V1",
            description="Bounds check bypass leading to speculative out-of-bounds access",
            semantic_requirements=[
                "bounds_check_present",
                "conditional_branch_after_check",
                "array_access_in_speculative_path",
                "probe_array_access"
            ],
            code_patterns=[
                "cmp.*jl.*mov.*\\[.*\\]",  # x86: compare, jump-if-less, memory access
                "cmp.*b\\.lt.*ldr.*\\[.*\\]"  # ARM: compare, branch-if-less, load
            ],
            context_requirements={
                "min_instructions": 5,
                "max_distance_bounds_to_access": 10,
                "requires_dependent_load": True
            },
            detection_heuristics=[
                "bounds_check_followed_by_array_access",
                "speculative_execution_window_present",
                "cache_side_channel_gadget"
            ],
            false_positive_filters=[
                "bounds_check_always_safe",
                "no_speculative_execution_possible",
                "access_within_proven_bounds"
            ]
        ))
        
        # Spectre V2 patterns
        patterns.append(VulnerabilityPattern(
            pattern_id="SPECTRE_V2_BTI",
            vuln_type="SPECTRE_V2",
            description="Branch Target Injection via indirect branch misprediction",
            semantic_requirements=[
                "indirect_branch_present",
                "branch_target_controllable",
                "speculative_execution_gadget",
                "information_leak_mechanism"
            ],
            code_patterns=[
                "jmp.*\\%r.*",  # x86: indirect jump with register
                "br.*x.*"      # ARM: branch to register
            ],
            context_requirements={
                "requires_indirect_branch": True,
                "requires_gadget_in_vicinity": True
            },
            detection_heuristics=[
                "indirect_branch_with_controllable_target",
                "speculation_gadget_reachable",
                "btb_training_possible"
            ],
            false_positive_filters=[
                "branch_target_not_controllable",
                "no_useful_gadgets_reachable",
                "speculation_barriers_present"
            ]
        ))
        
        # Meltdown patterns
        patterns.append(VulnerabilityPattern(
            pattern_id="MELTDOWN_PRIVILEGED_ACCESS",
            vuln_type="MELTDOWN",
            description="Speculative access to privileged memory",
            semantic_requirements=[
                "privileged_memory_access",
                "exception_handling_bypass",
                "dependent_load_chain",
                "cache_side_channel"
            ],
            code_patterns=[
                "mov.*%gs:.*",     # x86: segment register access
                "mrs.*ttbr.*"      # ARM: system register access
            ],
            context_requirements={
                "requires_privileged_access": True,
                "requires_exception_suppression": True
            },
            detection_heuristics=[
                "kernel_memory_access_attempt",
                "exception_suppression_mechanism",
                "speculative_execution_window"
            ],
            false_positive_filters=[
                "legitimate_kernel_code",
                "proper_privilege_checks",
                "no_speculative_access_possible"
            ]
        ))
        
        # BHI patterns
        patterns.append(VulnerabilityPattern(
            pattern_id="BHI_HISTORY_INJECTION",
            vuln_type="BHI",
            description="Branch History Injection via BHB pollution",
            semantic_requirements=[
                "branch_history_training",
                "indirect_branch_target",
                "cross_privilege_boundary",
                "speculation_gadget"
            ],
            code_patterns=[
                ".*jmp.*call.*jmp.*",  # Pattern of jumps and calls
                ".*b.*bl.*br.*"        # ARM branch pattern
            ],
            context_requirements={
                "requires_branch_sequence": True,
                "min_branch_count": 3
            },
            detection_heuristics=[
                "branch_history_pollution_sequence",
                "indirect_branch_misprediction_target",
                "cross_domain_speculation"
            ],
            false_positive_filters=[
                "no_cross_privilege_access",
                "branch_history_isolation",
                "no_useful_speculation_targets"
            ]
        ))
        
        return patterns
    
    def analyze_code_semantics(self, instructions: List[Dict], 
                             context: Dict[str, Any] = None) -> SemanticContext:
        """Perform comprehensive semantic analysis of code"""
        
        # Extract function context
        function_name = context.get('function_name', 'unknown') if context else 'unknown'
        
        # Analyze variable dependencies
        var_deps = self.data_flow_analyzer.analyze_dependencies(instructions)
        
        # Analyze control flow context
        cf_context = self.context_analyzer.analyze_control_flow(instructions)
        
        # Analyze data flow context
        df_context = self.data_flow_analyzer.analyze_data_flow(instructions)
        
        # Analyze speculation context
        spec_context = self.speculation_analyzer.analyze_speculation_potential(instructions)
        
        # Identify vulnerability indicators
        vuln_indicators = self._identify_vulnerability_indicators(instructions)
        
        # Calculate confidence factors
        confidence_factors = self._calculate_confidence_factors(
            instructions, var_deps, cf_context, df_context, spec_context
        )
        
        return SemanticContext(
            function_name=function_name,
            variable_dependencies=var_deps,
            control_flow_context=cf_context,
            data_flow_context=df_context,
            speculation_context=spec_context,
            vulnerability_indicators=vuln_indicators,
            confidence_factors=confidence_factors
        )
    
    def detect_semantic_vulnerabilities(self, instructions: List[Dict],
                                      context: SemanticContext = None) -> List[Dict[str, Any]]:
        """Detect vulnerabilities using semantic analysis"""
        
        if not context:
            context = self.analyze_code_semantics(instructions)
        
        detections = []
        
        for pattern in self.vulnerability_patterns:
            detection = self._match_semantic_pattern(instructions, context, pattern)
            if detection:
                detections.append(detection)
        
        # Rank detections by confidence
        detections.sort(key=lambda x: x.get('confidence', 0), reverse=True)
        
        return detections
    
    def _match_semantic_pattern(self, instructions: List[Dict], 
                               context: SemanticContext,
                               pattern: VulnerabilityPattern) -> Optional[Dict[str, Any]]:
        """Match instructions against a semantic vulnerability pattern"""
        
        # Check semantic requirements
        semantic_score = self._check_semantic_requirements(
            instructions, context, pattern.semantic_requirements
        )
        
        if semantic_score < 0.5:
            return None
        
        # Check code patterns
        code_score = self._check_code_patterns(instructions, pattern.code_patterns)
        
        # Check context requirements
        context_score = self._check_context_requirements(
            instructions, context, pattern.context_requirements
        )
        
        # Apply detection heuristics
        heuristic_score = self._apply_detection_heuristics(
            instructions, context, pattern.detection_heuristics
        )
        
        # Apply false positive filters
        fp_penalty = self._apply_false_positive_filters(
            instructions, context, pattern.false_positive_filters
        )
        
        # Calculate overall confidence
        confidence = (semantic_score * 0.3 + code_score * 0.25 + 
                     context_score * 0.25 + heuristic_score * 0.2) - fp_penalty
        
        if confidence > 0.4:  # Threshold for detection
            return {
                'pattern_id': pattern.pattern_id,
                'vuln_type': pattern.vuln_type,
                'description': pattern.description,
                'confidence': confidence,
                'semantic_score': semantic_score,
                'code_score': code_score,
                'context_score': context_score,
                'heuristic_score': heuristic_score,
                'fp_penalty': fp_penalty,
                'evidence': self._collect_evidence(instructions, context, pattern),
                'location': {
                    'start_line': instructions[0].get('line_num', 0) if instructions else 0,
                    'end_line': instructions[-1].get('line_num', 0) if instructions else 0
                }
            }
        
        return None
    
    def _check_semantic_requirements(self, instructions: List[Dict], 
                                   context: SemanticContext,
                                   requirements: List[str]) -> float:
        """Check if semantic requirements are met"""
        met_requirements = 0
        
        for req in requirements:
            if req == "bounds_check_present":
                if self._has_bounds_check(instructions):
                    met_requirements += 1
            elif req == "conditional_branch_after_check":
                if self._has_conditional_branch_after_check(instructions):
                    met_requirements += 1
            elif req == "array_access_in_speculative_path":
                if self._has_speculative_array_access(instructions, context):
                    met_requirements += 1
            elif req == "probe_array_access":
                if self._has_probe_array_pattern(instructions):
                    met_requirements += 1
            elif req == "indirect_branch_present":
                if self._has_indirect_branch(instructions):
                    met_requirements += 1
            elif req == "privileged_memory_access":
                if self._has_privileged_access(instructions):
                    met_requirements += 1
            elif req == "branch_history_training":
                if self._has_branch_history_training(instructions):
                    met_requirements += 1
        
        return met_requirements / len(requirements) if requirements else 0.0
    
    def _check_code_patterns(self, instructions: List[Dict], patterns: List[str]) -> float:
        """Check if code matches expected patterns"""
        if not patterns:
            return 1.0
        
        code_text = ' '.join([instr.get('raw_line', '') for instr in instructions])
        
        matched_patterns = 0
        for pattern in patterns:
            if re.search(pattern, code_text, re.IGNORECASE):
                matched_patterns += 1
        
        return matched_patterns / len(patterns)
    
    def _check_context_requirements(self, instructions: List[Dict],
                                  context: SemanticContext,
                                  requirements: Dict[str, Any]) -> float:
        """Check if context requirements are satisfied"""
        score = 1.0
        
        if "min_instructions" in requirements:
            if len(instructions) < requirements["min_instructions"]:
                score *= 0.5
        
        if "requires_indirect_branch" in requirements:
            if requirements["requires_indirect_branch"] and not self._has_indirect_branch(instructions):
                score *= 0.3
        
        if "requires_privileged_access" in requirements:
            if requirements["requires_privileged_access"] and not self._has_privileged_access(instructions):
                score *= 0.3
        
        return score
    
    def _apply_detection_heuristics(self, instructions: List[Dict],
                                  context: SemanticContext,
                                  heuristics: List[str]) -> float:
        """Apply detection heuristics"""
        score = 0.0
        
        for heuristic in heuristics:
            if heuristic == "bounds_check_followed_by_array_access":
                if self._check_bounds_check_array_access_pattern(instructions):
                    score += 0.3
            elif heuristic == "speculative_execution_window_present":
                if self._check_speculative_window(instructions, context):
                    score += 0.3
            elif heuristic == "cache_side_channel_gadget":
                if self._check_cache_side_channel(instructions):
                    score += 0.2
            elif heuristic == "indirect_branch_with_controllable_target":
                if self._check_controllable_indirect_branch(instructions):
                    score += 0.4
        
        return min(score, 1.0)
    
    def _apply_false_positive_filters(self, instructions: List[Dict],
                                    context: SemanticContext,
                                    filters: List[str]) -> float:
        """Apply false positive filters (returns penalty)"""
        penalty = 0.0
        
        for filter_name in filters:
            if filter_name == "bounds_check_always_safe":
                if self._is_bounds_check_always_safe(instructions):
                    penalty += 0.5
            elif filter_name == "no_speculative_execution_possible":
                if not context.speculation_context.get('speculation_possible', True):
                    penalty += 0.8
            elif filter_name == "legitimate_kernel_code":
                if self._is_legitimate_kernel_code(instructions, context):
                    penalty += 0.6
        
        return penalty
    
    def _collect_evidence(self, instructions: List[Dict], context: SemanticContext,
                         pattern: VulnerabilityPattern) -> Dict[str, Any]:
        """Collect evidence supporting the detection"""
        evidence = {
            'matching_instructions': [],
            'semantic_indicators': [],
            'control_flow_evidence': [],
            'data_flow_evidence': []
        }
        
        # Collect matching instructions
        for i, instr in enumerate(instructions):
            if self._instruction_matches_pattern(instr, pattern):
                evidence['matching_instructions'].append({
                    'line': instr.get('line_num', i),
                    'instruction': instr.get('raw_line', ''),
                    'relevance': 'pattern_match'
                })
        
        # Collect semantic indicators
        evidence['semantic_indicators'] = context.vulnerability_indicators
        
        # Collect control flow evidence
        evidence['control_flow_evidence'] = context.control_flow_context[:5]
        
        # Collect data flow evidence
        evidence['data_flow_evidence'] = context.data_flow_context[:5]
        
        return evidence
    
    # Helper methods for semantic analysis
    def _has_bounds_check(self, instructions: List[Dict]) -> bool:
        """Check if instructions contain bounds checking pattern"""
        for instr in instructions:
            opcode = instr.get('opcode', '').lower()
            if opcode in ['cmp', 'test', 'sub', 'subs'] and instr.get('semantics', {}).get('is_comparison', False):
                return True
        return False
    
    def _has_conditional_branch_after_check(self, instructions: List[Dict]) -> bool:
        """Check for conditional branch following comparison"""
        for i in range(len(instructions) - 1):
            if instructions[i].get('semantics', {}).get('is_comparison', False):
                if instructions[i + 1].get('semantics', {}).get('is_branch', False):
                    return True
        return False
    
    def _has_speculative_array_access(self, instructions: List[Dict], context: SemanticContext) -> bool:
        """Check for array access in speculative execution path"""
        has_memory_access = any(instr.get('semantics', {}).get('accesses_memory', False) 
                               for instr in instructions)
        speculation_possible = context.speculation_context.get('speculation_possible', False)
        return has_memory_access and speculation_possible
    
    def _has_probe_array_pattern(self, instructions: List[Dict]) -> bool:
        """Check for probe array access pattern (cache side channel)"""
        # Look for memory access with scaling/shifting (typical of probe arrays)
        for instr in instructions:
            raw_line = instr.get('raw_line', '').lower()
            if any(pattern in raw_line for pattern in ['shl', 'lsl', '*', '<<']):
                if instr.get('semantics', {}).get('accesses_memory', False):
                    return True
        return False
    
    def _has_indirect_branch(self, instructions: List[Dict]) -> bool:
        """Check for indirect branch instructions"""
        for instr in instructions:
            if instr.get('semantics', {}).get('is_indirect', False):
                return True
        return False
    
    def _has_privileged_access(self, instructions: List[Dict]) -> bool:
        """Check for privileged memory or register access"""
        for instr in instructions:
            raw_line = instr.get('raw_line', '').lower()
            if any(pattern in raw_line for pattern in ['%gs:', '%fs:', 'ttbr', 'sctlr', 'mrs', 'msr']):
                return True
        return False
    
    def _has_branch_history_training(self, instructions: List[Dict]) -> bool:
        """Check for branch history training pattern"""
        branch_count = sum(1 for instr in instructions 
                          if instr.get('semantics', {}).get('is_branch', False))
        return branch_count >= 3
    
    def _instruction_matches_pattern(self, instr: Dict, pattern: VulnerabilityPattern) -> bool:
        """Check if instruction matches vulnerability pattern"""
        raw_line = instr.get('raw_line', '')
        for code_pattern in pattern.code_patterns:
            if re.search(code_pattern, raw_line, re.IGNORECASE):
                return True
        return False
    
    # Additional helper methods for heuristic checks
    def _check_bounds_check_array_access_pattern(self, instructions: List[Dict]) -> bool:
        """Check for bounds check followed by array access pattern"""
        for i in range(len(instructions) - 2):
            if (instructions[i].get('semantics', {}).get('is_comparison', False) and
                instructions[i + 1].get('semantics', {}).get('is_branch', False) and
                instructions[i + 2].get('semantics', {}).get('accesses_memory', False)):
                return True
        return False
    
    def _check_speculative_window(self, instructions: List[Dict], context: SemanticContext) -> bool:
        """Check for speculative execution window"""
        return context.speculation_context.get('speculation_possible', False)
    
    def _check_cache_side_channel(self, instructions: List[Dict]) -> bool:
        """Check for cache side channel gadget"""
        return any(instr.get('semantics', {}).get('is_cache_operation', False) for instr in instructions)
    
    def _check_controllable_indirect_branch(self, instructions: List[Dict]) -> bool:
        """Check for controllable indirect branch"""
        return any(instr.get('semantics', {}).get('is_indirect', False) for instr in instructions)
    
    def _is_bounds_check_always_safe(self, instructions: List[Dict]) -> bool:
        """Check if bounds check is always safe (false positive filter)"""
        # Simplified heuristic - if there are speculation barriers, it's likely safe
        return any(instr.get('semantics', {}).get('is_speculation_barrier', False) for instr in instructions)
    
    def _is_legitimate_kernel_code(self, instructions: List[Dict], context: SemanticContext) -> bool:
        """Check if this is legitimate kernel code (false positive filter)"""
        # Simplified heuristic - check function name
        return 'kernel' in context.function_name.lower() or 'sys' in context.function_name.lower()
    
    def _identify_vulnerability_indicators(self, instructions: List[Dict]) -> List[str]:
        """Identify general vulnerability indicators in code"""
        indicators = []
        
        # Check for speculation-related patterns
        if any(instr.get('semantics', {}).get('is_speculation_barrier', False) for instr in instructions):
            indicators.append("speculation_barriers_present")
        
        # Check for timing-sensitive operations
        if any(instr.get('semantics', {}).get('is_timing_sensitive', False) for instr in instructions):
            indicators.append("timing_operations_present")
        
        # Check for cache operations
        if any(instr.get('semantics', {}).get('is_cache_operation', False) for instr in instructions):
            indicators.append("cache_operations_present")
        
        # Check for memory access patterns
        memory_accesses = sum(1 for instr in instructions 
                             if instr.get('semantics', {}).get('accesses_memory', False))
        if memory_accesses > len(instructions) * 0.3:
            indicators.append("high_memory_access_density")
        
        return indicators
    
    def _calculate_confidence_factors(self, instructions: List[Dict], 
                                    var_deps: Dict, cf_context: List[str],
                                    df_context: List[str], spec_context: Dict) -> Dict[str, float]:
        """Calculate confidence factors for vulnerability detection"""
        factors = {}
        
        # Instruction complexity factor
        factors['instruction_complexity'] = min(len(instructions) / 20.0, 1.0)
        
        # Control flow complexity
        branch_density = sum(1 for instr in instructions 
                            if instr.get('semantics', {}).get('is_branch', False)) / len(instructions)
        factors['control_flow_complexity'] = branch_density
        
        # Data dependency factor
        factors['data_dependency_complexity'] = min(len(var_deps) / 10.0, 1.0)
        
        # Speculation potential
        factors['speculation_potential'] = spec_context.get('speculation_score', 0.0)
        
        return factors

class ContextAnalyzer:
    """Analyzes control flow context"""
    
    def analyze_control_flow(self, instructions: List[Dict]) -> List[str]:
        """Analyze control flow patterns"""
        context = []
        
        for instr in instructions:
            semantics = instr.get('semantics', {})
            if semantics.get('is_branch', False):
                branch_type = "conditional" if semantics.get('is_conditional', False) else "unconditional"
                context.append(f"branch_{branch_type}")
            elif semantics.get('is_call', False):
                context.append("function_call")
            elif semantics.get('is_return', False):
                context.append("function_return")
        
        return context

class SpeculationAnalyzer:
    """Analyzes speculation potential"""
    
    def analyze_speculation_potential(self, instructions: List[Dict]) -> Dict[str, Any]:
        """Analyze potential for speculative execution"""
        context = {
            'speculation_possible': False,
            'speculation_score': 0.0,
            'speculation_indicators': []
        }
        
        # Check for branch misprediction potential
        has_branches = any(instr.get('semantics', {}).get('is_branch', False) for instr in instructions)
        has_conditional = any(instr.get('semantics', {}).get('is_conditional', False) for instr in instructions)
        
        if has_branches and has_conditional:
            context['speculation_possible'] = True
            context['speculation_score'] += 0.5
            context['speculation_indicators'].append("conditional_branches_present")
        
        # Check for memory access after branches
        for i in range(len(instructions) - 1):
            if instructions[i].get('semantics', {}).get('is_branch', False):
                if instructions[i + 1].get('semantics', {}).get('accesses_memory', False):
                    context['speculation_score'] += 0.3
                    context['speculation_indicators'].append("memory_access_after_branch")
                    break
        
        return context

class DataFlowAnalyzer:
    """Analyzes data flow and dependencies"""
    
    def analyze_dependencies(self, instructions: List[Dict]) -> Dict[str, List[str]]:
        """Analyze variable dependencies"""
        dependencies = defaultdict(list)
        
        # Simplified dependency analysis
        for instr in instructions:
            operands = instr.get('operands', [])
            if len(operands) >= 2:
                # Assume first operand is destination, rest are sources
                dest = operands[0]
                sources = operands[1:]
                dependencies[dest].extend(sources)
        
        return dict(dependencies)
    
    def analyze_data_flow(self, instructions: List[Dict]) -> List[str]:
        """Analyze data flow patterns"""
        patterns = []
        
        # Look for data dependency chains
        for i in range(len(instructions) - 1):
            instr1 = instructions[i]
            instr2 = instructions[i + 1]
            
            operands1 = set(instr1.get('operands', []))
            operands2 = set(instr2.get('operands', []))
            
            if operands1.intersection(operands2):
                patterns.append("data_dependency_chain")
        
        return patterns

def main():
    """Test the semantic vulnerability analyzer"""
    print("ðŸ§  Testing Semantic Vulnerability Analyzer")
    
    analyzer = SemanticVulnerabilityAnalyzer()
    
    # Test with sample instructions (Spectre V1 pattern)
    test_instructions = [
        {
            'line_num': 1,
            'raw_line': 'cmp %rax, %rbx',
            'opcode': 'cmp',
            'operands': ['%rax', '%rbx'],
            'semantics': {'is_comparison': True, 'is_branch': False, 'accesses_memory': False}
        },
        {
            'line_num': 2,
            'raw_line': 'jl .L1',
            'opcode': 'jl',
            'operands': ['.L1'],
            'semantics': {'is_branch': True, 'is_conditional': True, 'accesses_memory': False}
        },
        {
            'line_num': 3,
            'raw_line': 'mov (%rsi,%rax,8), %rdx',
            'opcode': 'mov',
            'operands': ['(%rsi,%rax,8)', '%rdx'],
            'semantics': {'is_load': True, 'accesses_memory': True, 'is_branch': False}
        }
    ]
    
    # Analyze semantics
    context = analyzer.analyze_code_semantics(test_instructions)
    print(f"ðŸ“Š Semantic Context:")
    print(f"   Vulnerability indicators: {context.vulnerability_indicators}")
    print(f"   Control flow context: {context.control_flow_context}")
    print(f"   Speculation context: {context.speculation_context}")
    
    # Detect vulnerabilities
    detections = analyzer.detect_semantic_vulnerabilities(test_instructions, context)
    print(f"\nðŸŽ¯ Detections: {len(detections)}")
    
    for detection in detections:
        print(f"   {detection['vuln_type']}: {detection['confidence']:.3f}")
        print(f"      {detection['description']}")

if __name__ == "__main__":
    main()