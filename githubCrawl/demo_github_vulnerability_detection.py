#!/usr/bin/env python3
"""
Demonstration Script: GitHub Vulnerability Detection
Shows how to use the complete integrated system to find vulnerabilities in real GitHub repositories
"""

import os
import json
import sqlite3
from pathlib import Path
from typing import List, Dict, Any

from github_vulnerability_scanner import GitHubVulnerabilityScanner

def demo_basic_scan():
    """Demonstrate basic vulnerability scanning"""
    print("üéØ DEMO: Basic GitHub Vulnerability Scan")
    print("="*60)
    
    # Initialize scanner
    scanner = GitHubVulnerabilityScanner()
    
    # Show what repositories we have
    repos = scanner.load_github_repositories()
    print(f"üìö Loaded {len(repos)} GitHub repositories")
    
    # Show what assembly files we have
    assembly_files = scanner.discover_assembly_files()
    print(f"üìÅ Discovered {len(assembly_files)} assembly files")
    
    if assembly_files:
        print("\nüîç Sample assembly files:")
        for i, asm_file in enumerate(assembly_files[:5]):
            print(f"   {i+1}. {Path(asm_file.filepath).name}")
            print(f"      Repository: {asm_file.repository}")
            print(f"      Architecture: {asm_file.architecture}")
            print(f"      Size: {asm_file.file_size:,} bytes")
    
    return scanner, assembly_files

def demo_single_file_scan(scanner, assembly_files):
    """Demonstrate scanning a single file"""
    print(f"\nüî¨ DEMO: Single File Vulnerability Analysis")
    print("="*60)
    
    if not assembly_files:
        print("‚ùå No assembly files available for scanning")
        return
    
    # Pick an interesting file (preferably from darwin-xnu for kernel vulnerabilities)
    target_file = None
    for asm_file in assembly_files:
        if 'darwin-xnu' in asm_file.filepath or 'security' in asm_file.filepath:
            target_file = asm_file
            break
    
    if not target_file:
        target_file = assembly_files[0]  # Use first file as fallback
    
    print(f"üéØ Analyzing: {Path(target_file.filepath).name}")
    print(f"   Repository: {target_file.repository}")
    print(f"   Source: {target_file.source_file}")
    print(f"   Architecture: {target_file.architecture}")
    
    # Initialize detectors
    print("\nü§ñ Initializing vulnerability detectors...")
    if not scanner.initialize_detectors():
        print("‚ùå Failed to initialize detectors")
        return
    
    # Scan with different detectors
    detectors = ["robust", "ensemble"]  # Skip semantic as it had issues
    
    for detector_type in detectors:
        print(f"\nüîç Scanning with {detector_type} detector...")
        try:
            matches = scanner.scan_assembly_file(target_file, detector_type)
            
            if matches:
                print(f"   ‚ö†Ô∏è  Found {len(matches)} potential vulnerabilities:")
                for i, match in enumerate(matches, 1):
                    print(f"      {i}. {match.vulnerability_type}")
                    print(f"         Confidence: {match.confidence:.3f}")
                    print(f"         Risk: {match.risk_level}")
                    print(f"         Location: lines {match.location.get('start_line', 0)}-{match.location.get('end_line', 0)}")
            else:
                print("   ‚úÖ No vulnerabilities detected")
                
        except Exception as e:
            print(f"   ‚ùå Error scanning with {detector_type}: {e}")

def demo_batch_scan(scanner):
    """Demonstrate batch scanning of multiple files"""
    print(f"\nüìä DEMO: Batch Vulnerability Scan")
    print("="*60)
    
    print("üöÄ Running batch scan on GitHub repositories...")
    print("   (Limited to 5 files for demo)")
    
    try:
        # Run scan with limited files
        results = scanner.run_full_scan(
            detector_type="ensemble",
            max_files=5
        )
        
        print(f"\nüìà Scan Results Summary:")
        print(f"   Files scanned: {results.get('scanned_files', 0)}")
        print(f"   Vulnerabilities found: {results.get('total_vulnerabilities', 0)}")
        print(f"   Failed files: {results.get('failed_files', 0)}")
        
        if results.get('vulnerabilities_by_type'):
            print(f"\nüéØ Vulnerabilities by type:")
            for vuln_type, count in results['vulnerabilities_by_type'].items():
                print(f"      {vuln_type}: {count}")
        
        if results.get('vulnerabilities_by_risk'):
            print(f"\n‚ö†Ô∏è  Risk distribution:")
            for risk_level, count in results['vulnerabilities_by_risk'].items():
                print(f"      {risk_level}: {count}")
        
        return results
        
    except Exception as e:
        print(f"‚ùå Batch scan failed: {e}")
        return {}

def demo_results_analysis(scanner):
    """Demonstrate analysis of scan results"""
    print(f"\nüìä DEMO: Results Analysis")
    print("="*60)
    
    db_path = scanner.db_path
    if not os.path.exists(db_path):
        print("‚ùå No scan results database found")
        return
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    # Get total vulnerabilities
    cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
    total_vulns = cursor.fetchone()[0]
    print(f"üìä Total vulnerabilities in database: {total_vulns}")
    
    if total_vulns == 0:
        print("   No vulnerabilities found in database")
        conn.close()
        return
    
    # Get vulnerabilities by type
    cursor.execute("""
        SELECT vulnerability_type, COUNT(*) as count 
        FROM vulnerabilities 
        GROUP BY vulnerability_type 
        ORDER BY count DESC
    """)
    vuln_by_type = cursor.fetchall()
    
    if vuln_by_type:
        print(f"\nüéØ Vulnerabilities by type:")
        for vuln_type, count in vuln_by_type:
            print(f"      {vuln_type}: {count}")
    
    # Get top vulnerable repositories
    cursor.execute("""
        SELECT repository, COUNT(*) as count 
        FROM vulnerabilities 
        GROUP BY repository 
        ORDER BY count DESC 
        LIMIT 5
    """)
    top_repos = cursor.fetchall()
    
    if top_repos:
        print(f"\nüèÜ Most vulnerable repositories:")
        for repo, count in top_repos:
            print(f"      {repo}: {count} vulnerabilities")
    
    # Get high-risk vulnerabilities
    cursor.execute("""
        SELECT repository, vulnerability_type, confidence, risk_level
        FROM vulnerabilities 
        WHERE risk_level IN ('CRITICAL', 'HIGH')
        ORDER BY confidence DESC
        LIMIT 5
    """)
    high_risk = cursor.fetchall()
    
    if high_risk:
        print(f"\nüö® High-risk vulnerabilities:")
        for repo, vuln_type, conf, risk in high_risk:
            print(f"      {vuln_type} in {repo} (confidence: {conf:.3f}, risk: {risk})")
    
    conn.close()

def demo_export_results(scanner):
    """Demonstrate exporting results for further analysis"""
    print(f"\nüì§ DEMO: Exporting Results")
    print("="*60)
    
    db_path = scanner.db_path
    if not os.path.exists(db_path):
        print("‚ùå No scan results database found")
        return
    
    # Export to CSV for spreadsheet analysis
    try:
        import pandas as pd
        
        conn = sqlite3.connect(db_path)
        
        # Export vulnerabilities to CSV
        df = pd.read_sql_query("SELECT * FROM vulnerabilities", conn)
        csv_file = "vulnerability_results.csv"
        df.to_csv(csv_file, index=False)
        print(f"üìä Exported {len(df)} vulnerabilities to {csv_file}")
        
        # Export summary statistics
        summary = {
            'total_vulnerabilities': len(df),
            'unique_repositories': df['repository'].nunique(),
            'vulnerability_types': df['vulnerability_type'].value_counts().to_dict(),
            'risk_distribution': df['risk_level'].value_counts().to_dict(),
            'average_confidence': df['confidence'].mean(),
            'high_confidence_count': len(df[df['confidence'] > 0.8])
        }
        
        with open('vulnerability_summary.json', 'w') as f:
            json.dump(summary, f, indent=2)
        print(f"üìà Exported summary statistics to vulnerability_summary.json")
        
        conn.close()
        
    except ImportError:
        print("‚ö†Ô∏è  pandas not available - skipping CSV export")
    except Exception as e:
        print(f"‚ùå Export failed: {e}")

def main():
    """Run complete demonstration"""
    print("üöÄ GitHub Vulnerability Detection System - Complete Demo")
    print("="*80)
    print("This demo shows how to use the robust vulnerability detection system")
    print("with real GitHub repositories and compiled assembly code.")
    print("="*80)
    
    try:
        # Demo 1: Basic scan setup
        scanner, assembly_files = demo_basic_scan()
        
        if not assembly_files:
            print("\n‚ùå No assembly files found. Please run the compilation pipeline first:")
            print("   1. python github.py")
            print("   2. python clone_repos.py") 
            print("   3. python find_c_cpp_files.py")
            print("   4. python compile_to_asm.py")
            return
        
        # Demo 2: Single file analysis
        demo_single_file_scan(scanner, assembly_files)
        
        # Demo 3: Batch scanning
        results = demo_batch_scan(scanner)
        
        # Demo 4: Results analysis
        demo_results_analysis(scanner)
        
        # Demo 5: Export results
        demo_export_results(scanner)
        
        print(f"\n‚úÖ Demo completed successfully!")
        print(f"üìÅ Check these files for results:")
        print(f"   - {scanner.db_path} (SQLite database)")
        print(f"   - github_vulnerability_scan_report.json (JSON report)")
        print(f"   - vulnerability_scan.log (detailed logs)")
        print(f"   - vulnerability_results.csv (CSV export)")
        print(f"   - vulnerability_summary.json (summary stats)")
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è  Demo interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Demo failed with error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()